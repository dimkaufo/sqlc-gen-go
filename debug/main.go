package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/sqlc-dev/plugin-sdk-go/plugin"

	golang "github.com/sqlc-dev/sqlc-gen-go/internal"
)

// This is a debug harness that allows you to run and debug the plugin
// with real captured data without needing sqlc to spawn it as a separate process
func main() {
	// Debug harness that runs the plugin with real captured data from sqlc

	fmt.Println("Starting debug session for sqlc-gen-go plugin...")

	// Run with captured input from file
	runFromFile()
}

func runFromFile() {
	// Try to read captured input from debug/capture/output/captured_input.json
	inputFile := "debug/capture/output/captured_input.json"
	data, err := os.ReadFile(inputFile)
	if err != nil {
		log.Printf("Could not read captured data: %v", err)
		log.Println("To capture real input data:")
		log.Println("1. Run: ./debug/capture/capture-real-data.sh [directory]")
		log.Println("2. Then debug: go run debug/main.go")
		log.Println("")
		log.Println("Examples:")
		log.Println("  ./debug/capture/capture-real-data.sh")
		log.Println("  ./debug/capture/capture-real-data.sh /path/to/your/sqlc/file/dir")
		log.Println("")
		log.Println("Or use the 'Capture Real Plugin Data' task in VS Code")
		return
	}

	var req plugin.GenerateRequest
	if err := json.Unmarshal(data, &req); err != nil {
		log.Fatalf("Failed to unmarshal input from %s: %v", inputFile, err)
	}

	fmt.Printf("Using real captured data from %s\n", inputFile)
	fmt.Printf("Processing request with %d queries\n", len(req.Queries))

	// Print some info about the captured data
	if req.Settings != nil {
		fmt.Printf("- Engine: %s\n", req.Settings.Engine)
		if req.Settings.Version != "" {
			fmt.Printf("- Version: %s\n", req.Settings.Version)
		}
	}

	if len(req.Queries) > 0 {
		fmt.Printf("- Queries: ")
		for i, q := range req.Queries {
			if i > 0 {
				fmt.Printf(", ")
			}
			fmt.Printf("%s", q.Name)
		}
		fmt.Printf("\n")
	}

	// Check if nested configuration exists in plugin options
	if len(req.PluginOptions) > 0 {
		var options map[string]interface{}
		if err := json.Unmarshal(req.PluginOptions, &options); err == nil {
			if nested, ok := options["nested"]; ok {
				fmt.Printf("- Has nested configuration: ✓\n")
				if nestedSlice, ok := nested.([]interface{}); ok {
					fmt.Printf("- Nested queries: %d\n", len(nestedSlice))
				}
			} else {
				fmt.Printf("- Has nested configuration: ✗\n")
			}
		}
	}

	fmt.Printf("\n🎯 Set breakpoints to debug!\n\n")

	// Set breakpoints in golang.Generate to debug
	ctx := context.Background()
	resp, err := golang.Generate(ctx, &req)
	if err != nil {
		log.Fatalf("Generation failed: %v", err)
	}

	// Create output directory structure matching sqlcout/
	os.MkdirAll("debug/output/query", 0755)
	os.MkdirAll("debug/output/entity", 0755)

	fmt.Printf("Generated %d files\n", len(resp.Files))
	for _, file := range resp.Files {
		fmt.Printf("- %s (%d bytes)\n", file.Name, len(file.Contents))

		// Save files maintaining the same directory structure as sqlcout/
		outputFile := fmt.Sprintf("debug/output/%s", file.Name)

		// Create subdirectory if needed
		if err := os.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
			fmt.Printf("  ❌ Failed to create directory for %s: %v\n", outputFile, err)
			continue
		}

		if err := os.WriteFile(outputFile, file.Contents, 0644); err == nil {
			if strings.Contains(file.Name, "nested") {
				fmt.Printf("  💾 Saved to %s (nested file)\n", outputFile)
			} else {
				fmt.Printf("  💾 Saved to %s\n", outputFile)
			}
		} else {
			fmt.Printf("  ❌ Failed to save %s: %v\n", outputFile, err)
		}
	}

	// Note: db.go should be generated by the plugin itself based on the captured data
	// If db.go is missing from the generated files, check your plugin configuration
}
