// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: books.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/sqlc-dev/sqlc-gen-go/example/sqlcout/entity"
)

const getBooks = `-- name: GetBooks :many
SELECT 
    b.id, b.title, b.author_id, b.published_at, b.created_at,
    r.id, r.book_id, r.rating, r.comment, r.reviewer_name, r.created_at,
    l.id, l.title, l.author_id, l.created_at
FROM books b
LEFT JOIN authors a ON a.id = b.author_id
LEFT JOIN labels l ON l.author_id = a.id
LEFT JOIN reviews r ON r.book_id = b.id
ORDER BY b.title, r.created_at
`

type GetBooksRow struct {
	Id          pgtype.UUID
	Title       string
	AuthorId    pgtype.UUID
	PublishedAt pgtype.Date
	CreatedAt   pgtype.Timestamptz
	Review      entity.Review
	Label       entity.Label
}

func (q *Queries) GetBooks(ctx context.Context) ([]*GetBooksGroup, error) {
	rows, err := q.db.Query(ctx, getBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBooksRow
	for rows.Next() {
		var i GetBooksRow
		if err := rows.Scan(
			&i.Id,
			&i.Title,
			&i.AuthorId,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.Review.Id,
			&i.Review.BookId,
			&i.Review.Rating,
			&i.Review.Comment,
			&i.Review.ReviewerName,
			&i.Review.CreatedAt,
			&i.Label.Id,
			&i.Label.Title,
			&i.Label.AuthorId,
			&i.Label.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return GroupGetBooks(items), nil
}
