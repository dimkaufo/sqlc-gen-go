# Nested Queries and Composites Documentation

## Overview

The nested queries functionality in `sqlc-gen-go` allows you to transform flat SQL query results into hierarchical, nested Go structures. This is particularly useful when working with joined tables where you want to group related records into nested slices or single objects within parent structures.

## Configuration Structure

The nested configuration is defined in your `sqlc.yaml` file under the `nested` key within the plugin options:

```yaml
plugins:
  - name: go
    out: ./output
    options:
      nested:
        composites: [] # Predefined reusable composite configurations
        queries: [] # Query-specific nested configurations
```

## Core Concepts

### 1. Composites

**Composites** are predefined, reusable structural configurations that define how to organize nested data. They allow you to define a grouping pattern once and reuse it across multiple queries.

#### Use Cases

- When multiple queries return similar nested structures
- When you want to maintain consistent data organization across your codebase
- When you need to define complex hierarchies that are used in multiple places

### 2. Queries

**Queries** are query-specific configurations that define how a particular SQL query's results should be structured into nested Go types.

#### Use Cases

- When a query has a unique nested structure
- When you need to override composite behavior for a specific query
- When the nesting pattern is only used once

## Configuration Reference

### NestedConfig

The root configuration object for nested query functionality.

```yaml
nested:
  composites: [] # Array of NestedCompositeConfig
  queries: [] # Array of NestedQueryConfig
```

| Field        | Type                      | Required | Description                                                       |
| ------------ | ------------------------- | -------- | ----------------------------------------------------------------- |
| `composites` | `[]NestedCompositeConfig` | No       | Predefined composite structures that can be reused across queries |
| `queries`    | `[]NestedQueryConfig`     | No       | Query-specific nested configurations                              |

---

### NestedCompositeConfig

Defines a reusable composite structure that can be referenced by multiple queries.

```yaml
composites:
  - name: "UserWithPosts"
    struct_root_in: "GetUserWithPostsRow"
    group:
      - struct_in: "Post"
        field_out: "Posts"
        # ... additional grouping configuration
```

| Field            | Type                  | Required | Default | Description                                                                                   |
| ---------------- | --------------------- | -------- | ------- | --------------------------------------------------------------------------------------------- |
| `name`           | `string`              | **Yes**  | -       | Unique identifier for this composite configuration                                            |
| `struct_root_in` | `string`              | **Yes**  | -       | The input struct name from the SQL query results (typically the Row struct generated by sqlc) |
| `group`          | `[]NestedGroupConfig` | No       | `[]`    | Array of nested group configurations defining the hierarchy                                   |

---

### NestedQueryConfig

Defines how a specific query's results should be structured into nested types.

```yaml
queries:
  - query: "GetUserWithPosts"
    struct_root: "UserWithPosts"
    field_group_by: "ID"
    group:
      - struct_in: "Post"
        field_out: "Posts"
        # ... additional grouping configuration
```

| Field            | Type                  | Required | Default | Description                                                        |
| ---------------- | --------------------- | -------- | ------- | ------------------------------------------------------------------ |
| `query`          | `string`              | **Yes**  | -       | The name of the SQL query (as defined in your `.sql` file)         |
| `struct_root`    | `string`              | **Yes**  | -       | The name of the root struct to generate for the nested result      |
| `field_group_by` | `string`              | No       | `"ID"`  | The field in the root struct to group by (typically a primary key) |
| `group`          | `[]NestedGroupConfig` | **Yes**  | -       | Array of nested group configurations                               |
| `composite`      | `*bool`               | No       | `false` | Whether this query uses a predefined composite configuration       |

---

### NestedGroupConfig

Defines how to group and nest a set of related records within a parent structure. This is the core configuration for building hierarchical data.

```yaml
group:
  - struct_in: "Post"
    struct_out: "Post"
    field_group_by: "UserID"
    field_out: "Posts"
    slice: true
    pointer: true
    composite: false
    group: [] # Recursive nesting
    match: [] # Field matching rules
```

| Field            | Type                  | Required | Default                | Description                                                                                   |
| ---------------- | --------------------- | -------- | ---------------------- | --------------------------------------------------------------------------------------------- |
| `struct_in`      | `string`              | **Yes**  | -                      | The input struct name (from query results) to be nested                                       |
| `struct_out`     | `string`              | No       | `struct_in`            | The output struct name for the nested type (useful for renaming)                              |
| `field_group_by` | `string`              | No       | `"ID"`                 | The field to use for grouping records together                                                |
| `field_out`      | `string`              | No       | Pluralized `struct_in` | The field name in the parent struct where nested data will be placed                          |
| `slice`          | `*bool`               | No       | `true`                 | Whether the nested field should be a slice (`[]Type`) or a single value (`Type`)              |
| `pointer`        | `*bool`               | No       | `true`                 | Whether nested items should be pointers (`*Type` or `[]*Type`)                                |
| `composite`      | `*bool`               | No       | `false`                | Whether to reuse an existing composite struct definition. **Mutually exclusive with `group`** |
| `group`          | `[]NestedGroupConfig` | No       | `[]`                   | Recursive nested group configurations. **Mutually exclusive with `composite: true`**          |
| `match`          | `[]NestedMatchConfig` | No       | `[]`                   | Field matching rules for complex relationships                                                |

#### Boolean Pointer Fields

The `slice`, `pointer`, and `composite` fields use `*bool` (nullable boolean) to distinguish between:

- **Not set** (nil): Use default value
- **Explicitly set**: Use the specified value

This allows you to explicitly disable defaults when needed.

#### Composite vs Group - Mutual Exclusivity

**Important**: When `composite: true` is set, you **must not** define a `group` array on the same level. The composite itself defines the grouping structure, so defining both would be redundant and conflicting.

```yaml
# ✅ Correct: Using composite without group
group:
  - struct_in: "PostWithComments"
    composite: true
    # No group field here

# ❌ Wrong: Composite with group on same level
group:
  - struct_in: "PostWithComments"
    composite: true
    group:  # ERROR: Cannot have both composite and group
      - struct_in: "Comment"
```

---

### NestedMatchConfig

Defines custom matching rules for relating nested structures when the default field matching isn't sufficient.

```yaml
match:
  - from_struct: "User"
    from_field: "ID"
    to_struct: "Post"
    to_field: "UserID"
```

| Field         | Type      | Required | Default                    | Description                                         |
| ------------- | --------- | -------- | -------------------------- | --------------------------------------------------- |
| `from_struct` | `*string` | No       | Parent struct              | The struct containing the source field for matching |
| `from_field`  | `*string` | No       | `field_group_by` of parent | The field in the source struct to match from        |
| `to_struct`   | `string`  | **Yes**  | -                          | The struct to match to (the nested struct)          |
| `to_field`    | `*string` | No       | `field_group_by` of nested | The field in the target struct to match by          |

#### When to Use Match

Use `match` configurations when:

- Foreign key relationships don't follow standard naming conventions
- Multiple levels of nesting require explicit field mappings
- You need to match on fields other than IDs
- Complex many-to-many relationships exist

---

## Complete Examples

### Example 1: Simple One-Level Nesting

**Scenario**: Users with their posts

```sql
-- name: GetUsersWithPosts :many
SELECT
    u.id AS user_id,
    u.name AS user_name,
    u.email AS user_email,
    p.id AS post_id,
    p.title AS post_title,
    p.content AS post_content,
    p.user_id AS post_user_id
FROM users u
LEFT JOIN posts p ON u.id = p.user_id
ORDER BY u.id, p.id;
```

**Configuration**:

```yaml
nested:
  queries:
    - query: "GetUsersWithPosts"
      struct_root: "UserWithPosts"
      field_group_by: "UserID"
      group:
        - struct_in: "Post"
          field_out: "Posts"
          field_group_by: "PostID"
          slice: true
          pointer: true
```

**Generated Go Code**:

```go
type Post struct {
    PostID      int64
    PostTitle   string
    PostContent string
    PostUserID  int64
}

type UserWithPosts struct {
    UserID    int64
    UserName  string
    UserEmail string
    Posts     []*Post  // Nested slice of posts
}

func (q *Queries) GetUsersWithPosts(ctx context.Context) ([]*UserWithPosts, error) {
    // Implementation that groups posts by user
}
```

---

### Example 2: Multi-Level Nesting

**Scenario**: Users with posts, and each post has comments

```sql
-- name: GetUsersWithPostsAndComments :many
SELECT
    u.id, u.name, u.email,
    p.id AS post_id, p.title, p.content,
    c.id AS comment_id, c.text AS comment_text, c.author
FROM users u
LEFT JOIN posts p ON u.id = p.user_id
LEFT JOIN comments c ON p.id = c.post_id
ORDER BY u.id, p.id, c.id;
```

**Configuration**:

```yaml
nested:
  queries:
    - query: "GetUsersWithPostsAndComments"
      struct_root: "UserWithPostsAndComments"
      field_group_by: "ID"
      group:
        - struct_in: "Post"
          field_out: "Posts"
          field_group_by: "PostID"
          slice: true
          pointer: true
          group:
            - struct_in: "Comment"
              field_out: "Comments"
              field_group_by: "CommentID"
              slice: true
              pointer: true
```

**Generated Structure**:

```go
type Comment struct {
    CommentID   int64
    CommentText string
    Author      string
}

type Post struct {
    PostID   int64
    Title    string
    Content  string
    Comments []*Comment  // Nested comments
}

type UserWithPostsAndComments struct {
    ID    int64
    Name  string
    Email string
    Posts []*Post  // Nested posts with comments
}
```

---

### Example 3: Using Composites for Reusability

**Scenario**: Multiple queries return posts with comments

```yaml
nested:
  # Define the composite once
  composites:
    - name: "PostWithComments"
      struct_root_in: "PostRow"
      group:
        - struct_in: "Comment"
          field_out: "Comments"
          field_group_by: "CommentID"
          slice: true
          pointer: true

  # Use the composite in multiple queries
  queries:
    - query: "GetUserPosts"
      struct_root: "UserPostsResult"
      field_group_by: "UserID"
      group:
        - struct_in: "PostWithComments"
          composite: true
          # Note: No 'group' field here because composite: true

    - query: "GetRecentPosts"
      struct_root: "RecentPostsResult"
      field_group_by: "PostID"
      group:
        - struct_in: "PostWithComments"
          composite: true
          # Note: No 'group' field here because composite: true
```

**Key Points**:

- The composite `PostWithComments` defines the structure once
- Multiple queries reference it using `composite: true`
- When using `composite: true`, do **not** add a `group` field on the same level

---

### Example 4: Single Object Nesting (Not a Slice)

**Scenario**: Posts with author information (one-to-one)

```yaml
nested:
  queries:
    - query: "GetPostsWithAuthor"
      struct_root: "PostWithAuthor"
      field_group_by: "PostID"
      group:
        - struct_in: "Author"
          field_out: "Author"
          slice: false # Single object, not a slice
          pointer: true # Use pointer for optional author
```

**Generated**:

```go
type Author struct {
    ID    int64
    Name  string
    Email string
}

type PostWithAuthor struct {
    PostID  int64
    Title   string
    Content string
    Author  *Author  // Single author object (pointer)
}
```

---

### Example 5: Custom Field Matching

**Scenario**: Complex matching with non-standard field names

```yaml
nested:
  queries:
    - query: "GetOrganizationsWithMembers"
      struct_root: "OrganizationWithMembers"
      field_group_by: "OrgID"
      group:
        - struct_in: "Member"
          field_out: "Members"
          field_group_by: "MemberID"
          match:
            - from_struct: "Organization"
              from_field: "OrgID"
              to_struct: "Member"
              to_field: "OrganizationID"
```

---

## Best Practices

### 1. Naming Conventions

- Use descriptive `struct_root` names that clearly indicate the nesting (e.g., `UserWithPosts`, `OrderWithItems`)
- Keep `field_out` names plural for slices and singular for single objects
- Use consistent casing with your project's style guide

### 2. Performance Considerations

- **Grouping fields**: Always group by unique identifiers (primary keys) to avoid duplicate aggregation
- **Ordering**: Ensure your SQL query is ordered by the grouping fields (parent to child) for optimal processing
- **Indexes**: Make sure foreign key columns used in JOINs are indexed

### 3. Query Optimization

```sql
-- Good: Properly ordered for nested grouping
SELECT ...
FROM users u
LEFT JOIN posts p ON u.id = p.user_id
LEFT JOIN comments c ON p.id = c.post_id
ORDER BY u.id, p.id, c.id;  -- Order matches nesting hierarchy

-- Bad: Unordered or wrong order
SELECT ...
FROM users u
LEFT JOIN posts p ON u.id = p.user_id
ORDER BY p.id;  -- Wrong order for grouping by user
```

### 4. When to Use Composites

✅ **Use Composites When**:

- The same nested structure appears in 3+ queries
- You want to enforce consistency across the codebase
- The structure is complex and benefits from centralized definition

❌ **Don't Use Composites When**:

- The structure is used only once or twice
- Each query needs significant customization
- The pattern is simple and self-documenting

### 5. Pointer vs Value Semantics

```yaml
# Use pointers (default) for:
pointer: true
# - Optional relationships (LEFT JOIN)
# - Large structs (memory efficiency)
# - When you need to distinguish between zero value and missing data

# Use values when:
pointer: false
# - Required relationships (INNER JOIN)
# - Small structs (performance)
# - When zero values are acceptable
```

### 6. Slice vs Single Object

```yaml
# Use slice (default) for:
slice: true
# - One-to-many relationships
# - Arrays of related items
# - When 0 or more items are expected

# Use single object for:
slice: false
# - One-to-one relationships
# - Single related item
# - When exactly 0 or 1 item is expected
```

---

## Troubleshooting

### Common Issues

#### 1. Duplicate Records in Results

**Problem**: Parent records appear multiple times in the output.

**Solution**:

- Check that `field_group_by` uses a unique identifier (primary key)
- Verify SQL query is properly ordered
- Ensure grouping hierarchy matches JOIN order

#### 2. Missing Nested Data

**Problem**: Nested slices are empty when data exists in the database.

**Solution**:

- Verify field names match between SQL aliases and config
- Check that `match` configuration correctly maps foreign keys
- Ensure SQL JOINs are correct (LEFT JOIN vs INNER JOIN)

#### 3. Type Mismatch Errors

**Problem**: Generated code doesn't compile due to type mismatches.

**Solution**:

- Verify `struct_in` names match the generated Row struct fields
- Check that `field_group_by` refers to existing fields
- Ensure consistent type usage across nested levels

#### 4. Composite Not Found

**Problem**: Error when trying to use a composite in a query.

**Solution**:

- Verify the composite `name` matches the reference in `struct_in`
- Ensure `composite: true` is set in the group configuration
- Check that the composite is defined in the `composites` array

#### 5. Composite and Group Conflict

**Problem**: Configuration error about having both `composite` and `group` defined.

**Solution**:

- Remove the `group` field when using `composite: true`
- The composite itself defines the grouping structure
- If you need custom grouping, either modify the composite definition or don't use `composite: true`

```yaml
# ❌ Wrong
group:
  - struct_in: "PostWithComments"
    composite: true
    group:  # ERROR: Remove this
      - struct_in: "Comment"

# ✅ Correct
group:
  - struct_in: "PostWithComments"
    composite: true
    # No group field
```

---

## Advanced Patterns

### Many-to-Many Relationships

For many-to-many relationships through a junction table:

```yaml
nested:
  queries:
    - query: "GetStudentsWithCourses"
      struct_root: "StudentWithCourses"
      field_group_by: "StudentID"
      group:
        - struct_in: "Course"
          field_out: "Courses"
          field_group_by: "CourseID"
          match:
            - from_struct: "Student"
              from_field: "StudentID"
              to_struct: "Enrollment"
              to_field: "StudentID"
```

### Self-Referencing Hierarchies

For tree structures (e.g., comments with replies):

```yaml
nested:
  queries:
    - query: "GetCommentsWithReplies"
      struct_root: "CommentThread"
      field_group_by: "CommentID"
      group:
        - struct_in: "Reply"
          field_out: "Replies"
          field_group_by: "ReplyID"
          match:
            - to_struct: "Reply"
              to_field: "ParentCommentID"
```

---

## Migration Guide

### From Flat Queries to Nested Queries

**Before** (flat):

```go
rows, err := q.GetUsersAndPosts(ctx)
// Manual grouping logic required
userMap := make(map[int64]*User)
for _, row := range rows {
    // Complex grouping code...
}
```

**After** (nested):

```go
users, err := q.GetUsersWithPosts(ctx)
// Already grouped!
for _, user := range users {
    for _, post := range user.Posts {
        // Use directly
    }
}
```

---

## Configuration Validation

The plugin validates configurations at generation time. Common validation errors:

| Error                          | Cause                                      | Fix                                             |
| ------------------------------ | ------------------------------------------ | ----------------------------------------------- |
| `struct_in required`           | Missing required field                     | Add `struct_in` to group config                 |
| `query not found`              | Query name doesn't match SQL               | Verify query name matches `-- name:` annotation |
| `composite not found`          | Referenced composite doesn't exist         | Check composite name spelling                   |
| `circular dependency`          | Nested groups reference each other         | Restructure to avoid cycles                     |
| `composite and group conflict` | Both `composite: true` and `group` defined | Remove `group` when using `composite: true`     |

---

## Performance Tips

1. **Limit result sets**: Use pagination in your SQL queries
2. **Index foreign keys**: Ensure JOINed columns are indexed
3. **Use appropriate JOIN types**: Use INNER JOIN when relationships are required
4. **Order results correctly**: Order by grouping fields to enable efficient processing
5. **Consider denormalization**: For very complex nesting, consider separate queries

---

## See Also

- [sqlc Configuration Documentation](https://docs.sqlc.dev/en/latest/reference/config.html)
- [Go sqlc Plugin Options](https://docs.sqlc.dev/en/latest/reference/language-support.html#go)
- [SQL Best Practices for Nested Queries](#)

---

## Version Compatibility

This nested query functionality requires:

- `sqlc` version: 1.20.0+
- `sqlc-gen-go` plugin: Custom fork with nested support

---

## Changelog

### v1.0.0

- Initial nested query support
- Composites functionality
- Match configuration
- Multi-level nesting support
