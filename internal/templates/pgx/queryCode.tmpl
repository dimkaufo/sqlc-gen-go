{{- /* Helper template: Declare nullable variables for embed fields before Scan */}}
{{define "declareEmbedNullableVars"}}
{{- $retName := index . 0}}
{{- $retStruct := index . 1}}
{{- $modelsPackage := index . 2}}
{{- if $retStruct}}
{{- range $fieldIdx, $field := $retStruct.Fields}}
{{- if $field.EmbedFields}}
{{- range $embedIdx, $embed := $field.EmbedFields}}
	var {{$retName}}{{$field.Name}}{{$embed.Name}} {{getNullableType $embed.Type $modelsPackage}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}

{{- /* Helper template: Construct embed from nullable fields after successful scan */}}
{{define "constructEmbedFromNullables"}}
{{- $retName := index . 0}}
{{- $retStruct := index . 1}}
{{- $modelsPackage := index . 2}}
{{- if $retStruct}}
{{- range $field := $retStruct.Fields}}
{{- if $field.EmbedFields}}
	// Check if {{$field.Name}} embed is null and construct accordingly
{{- $firstEmbed := index $field.EmbedFields 0}}
	if {{$retName}}{{$field.Name}}{{$firstEmbed.Name}}.Valid {
		{{$retName}}.{{$field.Name}} = {{$field.Type}}{
			{{- range $embed := $field.EmbedFields}}
			{{- $valueField := getNullableValueField $embed.Type $modelsPackage}}
			{{$embed.Name}}: {{$retName}}{{$field.Name}}{{$embed.Name}}{{- if ne $valueField ""}}.{{$valueField}}{{- end}},
			{{- end}}
		}
	} else {
		// Create default {{$field.Name}} with invalid/zero values for all fields
		{{$retName}}.{{$field.Name}} = {{$field.Type}}{}
	}
{{- end}}
{{- end}}
{{- end}}
{{- end}}

{{define "queryCodePgx"}}
{{$modelsPackage := .OutputModelsPackage}}

{{range .GoQueries}}
{{if $.OutputQuery .SourceName}}
{{if and (ne .Cmd ":copyfrom") (ne (hasPrefix .Cmd ":batch") true)}}
const {{.ConstantName}} = {{$.Q}}-- name: {{.MethodName}} {{.Cmd}}
{{escape .SQL}}
{{$.Q}}
{{end}}

{{if ne (hasPrefix .Cmd ":batch") true}}
{{if .Arg.EmitStruct}}
type {{.Arg.Type}} struct { {{- range .Arg.Struct.Fields}}
  {{.Name}} {{.Type}} {{if .Tag}}{{$.Q}}{{.Tag}}{{$.Q}}{{end}}
  {{- end}}
}
{{end}}

{{if .Ret.EmitStruct}}
type {{.Ret.Type}} struct { {{- range .Ret.Struct.Fields}}
  {{.Name}} {{.Type}} {{if .Tag}}{{$.Q}}{{.Tag}}{{$.Q}}{{end}}
  {{- end}}
}

{{ template "nestedRowEntityFieldGetter" (list . $modelsPackage) }}
{{end}}
{{end}}

{{if eq .Cmd ":one"}}
{{range .Comments}}//{{.}}
{{end -}}
{{- if $.EmitMethodsWithDBArgument -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, db DBTX, {{.Arg.Pair}}) ({{.FinalSingleReturnType}}, error) {
	row := db.QueryRow(ctx, {{.ConstantName}}, {{.Arg.Params}})
{{- else -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{.Arg.Pair}}) ({{.FinalSingleReturnType}}, error) {
	row := q.db.QueryRow(ctx, {{.ConstantName}}, {{.Arg.Params}})
{{- end}}
	{{- if or (ne .Arg.Pair .Ret.Pair) (ne .Arg.DefineType .Ret.DefineType) }}
	var {{.Ret.Name}} {{.Ret.Type}}
	{{- end}}
	{{- /* Declare nullable variables for embed fields before Scan */}}
	{{- template "declareEmbedNullableVars" (list .Ret.Name .Ret.Struct $modelsPackage)}}
	{{- if .Ret.Struct}}
	err := row.Scan(
		{{- $retName := .Ret.Name}}
		{{- range $fidx, $field := .Ret.Struct.Fields}}
		{{- if $field.EmbedFields}}
		{{- range $eidx, $embed := $field.EmbedFields}}
		&{{$retName}}{{$field.Name}}{{$embed.Name}},
		{{- end}}
		{{- else}}
		&{{$retName}}.{{$field.Name}},
		{{- end}}
		{{- end}}
	)
	{{- else}}
	err := row.Scan({{.Ret.Scan}})
	{{- end}}
	{{- /* Construct embed from nullable fields after successful scan */}}
	{{- template "constructEmbedFromNullables" (list .Ret.Name .Ret.Struct $modelsPackage)}}
	{{- if .ShouldCallGroupFunction }}
	if err != nil {
		{{- if .EmitResultStructPointers}}
		return nil, err
		{{- else}}
		var zero {{.GroupReturnType}}
		return zero, err
		{{- end}}
	}
	grouped := {{.GroupFunctionName}}([]{{.Ret.DefineType}}{{"{"}}{{.Ret.ReturnName}}{{"}"}})
	if len(grouped) == 0 {
		{{- if .EmitResultStructPointers}}
		return nil, nil
		{{- else}}
		var zero {{.GroupReturnType}}
		return zero, nil
		{{- end}}
	}
	return grouped[0], nil
	{{- else}}
	return {{.Ret.ReturnName}}, err
	{{- end}}
}
{{end}}

{{if eq .Cmd ":many"}}
{{range .Comments}}//{{.}}
{{end -}}
{{- if $.EmitMethodsWithDBArgument -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, db DBTX, {{.Arg.Pair}}) ({{.FinalSliceReturnType}}, error) {
	rows, err := db.Query(ctx, {{.ConstantName}}, {{.Arg.Params}})
{{- else -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{.Arg.Pair}}) ({{.FinalSliceReturnType}}, error) {
	rows, err := q.db.Query(ctx, {{.ConstantName}}, {{.Arg.Params}})
{{- end}}
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	{{- if $.EmitEmptySlices}}
	items := []{{.Ret.DefineType}}{}
	{{else}}
	var items []{{.Ret.DefineType}}
	{{end -}}
	for rows.Next() {
		var {{.Ret.Name}} {{.Ret.Type}}
		{{- /* Declare nullable variables for embed fields before Scan */}}
		{{- template "declareEmbedNullableVars" (list .Ret.Name .Ret.Struct $modelsPackage)}}
		{{- if .Ret.Struct}}
		if err := rows.Scan(
			{{- $retName := .Ret.Name}}
			{{- range $fidx, $field := .Ret.Struct.Fields}}
			{{- if $field.EmbedFields}}
			{{- range $eidx, $embed := $field.EmbedFields}}
			&{{$retName}}{{$field.Name}}{{$embed.Name}},
			{{- end}}
			{{- else}}
			&{{$retName}}.{{$field.Name}},
			{{- end}}
			{{- end}}
		); err != nil {
			return nil, err
		}
		{{- else}}
		if err := rows.Scan({{.Ret.Scan}}); err != nil {
			return nil, err
		}
		{{- end}}
		{{- /* Construct embed from nullable fields after successful scan */}}
		{{- template "constructEmbedFromNullables" (list .Ret.Name .Ret.Struct $modelsPackage)}}
		items = append(items, {{.Ret.ReturnName}})
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	{{- if .ShouldCallGroupFunction }}
	return {{.GroupFunctionName}}(items), nil
	{{- else}}
	return items, nil
	{{- end}}
}
{{end}}

{{if eq .Cmd ":exec"}}
{{range .Comments}}//{{.}}
{{end -}}
{{- if $.EmitMethodsWithDBArgument -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, db DBTX, {{.Arg.Pair}}) error {
	_, err := db.Exec(ctx, {{.ConstantName}}, {{.Arg.Params}})
{{- else -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{.Arg.Pair}}) error {
	_, err := q.db.Exec(ctx, {{.ConstantName}}, {{.Arg.Params}})
{{- end}}
	return err
}
{{end}}

{{if eq .Cmd ":execrows"}}
{{range .Comments}}//{{.}}
{{end -}}
{{if $.EmitMethodsWithDBArgument -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, db DBTX, {{.Arg.Pair}}) (int64, error) {
	result, err := db.Exec(ctx, {{.ConstantName}}, {{.Arg.Params}})
{{- else -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{.Arg.Pair}}) (int64, error) {
	result, err := q.db.Exec(ctx, {{.ConstantName}}, {{.Arg.Params}})
{{- end}}
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
{{end}}

{{if eq .Cmd ":execresult"}}
{{range .Comments}}//{{.}}
{{end -}}
{{- if $.EmitMethodsWithDBArgument -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, db DBTX, {{.Arg.Pair}}) (pgconn.CommandTag, error) {
	return db.Exec(ctx, {{.ConstantName}}, {{.Arg.Params}})
{{- else -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{.Arg.Pair}}) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, {{.ConstantName}}, {{.Arg.Params}})
{{- end}}
}
{{end}}


{{end}}
{{end}}
{{end}}
