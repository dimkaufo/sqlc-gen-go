{{- /* Generate query struct wrapper function for one we already generated by reusing the Group function */ -}}
{{ define "nestedGeneratedQueryGroupWrapper" -}}
  {{ $ptr := ternary .EmitPointers "*" ""}}
  {{ $oppositePtr := ternary .EmitPointers "" "*"}}
  {{ $QueryName := .Query.MethodName }}

  // {{.FunctionName}} groups flat {{$QueryName}} rows into nested {{.RootStructName}} structures by reusing Group{{.CastToQueryName}}
  func {{.FunctionName}}(rows []{{$ptr}}{{$QueryName}}Row) []{{$ptr}}{{.RootStructName}} {
    // Cast {{$QueryName}}Row to {{.CastToQueryName}}Row and reuse existing Group function
    var castedRows []{{$ptr}}{{.CastToQueryName}}Row
    for _, row := range rows {
      castedRows = append(castedRows, ({{$ptr}}{{.CastToQueryName}}Row)({{$oppositePtr}}row))
    }
    
    return Group{{.CastToQueryName}}(castedRows)
  }
{{- end }}

{{- /* Generate base fiels of tne structs that we take from the rows */ -}}
{{ define "baseStructField" -}}
  {{- $field := index . 0 -}}
  {{- $parent := index . 1 -}}
  {{- $fieldTags := joinTags $field.Tags -}}

  {{ $field.Name }} {{ $field.Type }} {{ ternary $parent.EmitJSONTags $fieldTags "" }}
{{- end }}

{{- /* Generate nested struct field */ -}}
{{ define "nestedStructField" -}}
  {{- $field := index . 0 -}}
  {{- $parent := index . 1 -}}
  {{- $fieldTags := joinTags $field.FieldTags -}}

  {{ $field.FieldName }} {{ $field.FieldType }} {{ ternary $parent.EmitJSONTags $fieldTags "" }}
{{- end }}

{{- /* Generate struct */ -}}
{{ define "generateStruct" }}
  {{- $currentStruct := index . 0 -}}
  {{- $templateData := index . 1 -}}

  {{- /* Rendered struct definition */ -}}
  // {{ $currentStruct.StructOut }} represents grouped data for {{ $currentStruct.StructOut }}
  type {{ $currentStruct.StructOut }} struct {
    {{- range $currentStruct.Fields }}
      {{ template "baseStructField" (list . $templateData) }}
    {{- end }}

    // Nested fields
    {{- range $currentStruct.NestedStructs }}
      {{ template "nestedStructField" (list . $templateData) }}
    {{- end }}
  }
{{ end }}

{{- /* Recursive template to generate nested structs at any depth */ -}}
{{ define "generateNestedStructs" -}}
  {{- $nestedStructs := index . 0 -}}
  {{- $templateData := index . 1 -}}
  
  {{- range $nestedStructs }}
    {{- if and (not .IsEntityStruct) (not .SkipStructGeneration) }}
      {{- /* Generate struct */ -}}
      {{ template "generateStruct" (list . $templateData) }}

      {{- /* Recursively generate nested structs for this struct */ -}}
      {{- if .NestedStructs }}
        {{ template "generateNestedStructs" (list .NestedStructs $templateData) }}
      {{- end }}
    {{- end }}
  {{- end }}
{{- end }}

{{- /* Recursive maps initialization */ -}}
{{define "nestedMapsRecursive"}}
  {{- $parentStruct := index . 0 -}}
  {{- $level := index . 1 -}}
  {{- $prefix := index . 2 -}}

  {{- range $parentStruct.NestedStructs }}
    {{$currentStructMaps := printf "%sMaps" .StructOut | camelCase -}}
    {{$StructName := printf "%s" (ternary .IsEntityStruct (printf "entity.%s" .StructIn) .StructOut) -}}
    {{- $nextPrefix := render "nextMapPrefix" (list . $parentStruct $level $prefix) -}}

    {{- /* Rendered maps definition */ -}}
    {{template "prefixedMapName" (list . $nextPrefix)}} := make(map[string]map[{{.KeyType}}]*{{$StructName}})
    {{- if and .NestedStructs }}
      {{- template "nestedMapsRecursive" (list . (add $level 1) $nextPrefix) -}}
    {{- end }}
  {{- end -}}
{{- end -}}

{{- /* Generate next map prefix */ -}}
{{define "nextMapPrefix"}}
  {{- $currentStruct := index . 0 -}}
  {{- $parentStruct := index . 1 -}}
  {{- $level := index . 2 -}}
  {{- $prefix := index . 3 -}}
  
  {{- $parentStructPrefix := $parentStruct.FieldName | camelCase -}}
  {{- $nextPrefix := $prefix -}}
  {{- /* Check if StructOut is duplicated at this level to determine if we need a prefix */ -}}
  {{- $isDuplicated := index $currentStruct.DuplicatedRelativeToParents $level -}}
  {{- if and $isDuplicated (eq $prefix "") -}}
    {{- $nextPrefix = $parentStructPrefix -}}
  {{- end -}}

  {{- /* Return next prefix */ -}}
  {{$nextPrefix}}
{{- end -}}

{{- /* Generate prefixed map name */ -}}
{{define "prefixedMapName"}}
  {{- $currentStruct := index . 0 -}}
  {{- $prefix := index . 1 -}}

  {{- $structMapItem := $currentStruct.StructOut | camelCase }}
  {{- $StructName := printf "%s" (ternary $currentStruct.IsEntityStruct (printf "entity.%s" $currentStruct.StructIn) $currentStruct.StructOut) }}
  {{- $structMaps := printf "%sMaps" $structMapItem }}
  {{- $prefixedStuctMaps := $structMaps -}}
  {{- if ne $prefix "" -}}
    {{- $prefixedStuctMaps = printf "%s%s" $prefix ($structMaps | upperTitle) -}}
  {{- end -}}

  {{- /* Return prefixed struct maps */ -}}
  {{$prefixedStuctMaps}}
{{- end -}}

{{- /* Recursive maps struct fields definition */ -}}
{{define "generateDefinePopulateMapsStructFieldsRecursive"}}
  {{- $parentStruct := index . 0 -}}
  {{- $level := index . 1 -}}
  {{- $prefix := index . 2 -}}
  {{- $parentStructPrefix := $parentStruct.FieldName | camelCase -}}

  {{- range $parentStruct.NestedStructs}}
    {{- $StructName := printf "%s" (ternary .IsEntityStruct (printf "entity.%s" .StructIn) .StructOut) }}
    {{- $nextPrefix := render "nextMapPrefix" (list . $parentStruct $level $prefix) -}}

    {{- /* Rendered fields definition */ -}}
    {{template "prefixedMapName" (list . $nextPrefix)}} map[string]map[{{.KeyType}}]*{{$StructName}}
    {{template "generateDefinePopulateMapsStructFieldsRecursive" (list . (add $level 1) $nextPrefix)}}
  {{- end}}
{{- end}}

{{define "generateDefinePopulateMapsStruct"}}
  {{- $PopulateStructName := printf "Populate%sMaps" .StructOut }}
  // {{$PopulateStructName}} represents the populate maps struct for {{.StructOut}}
  type {{$PopulateStructName}} struct {
    {{ template "generateDefinePopulateMapsStructFieldsRecursive" (list . 1 "")}}
  }
{{- end}}

{{- /* Define populate maps struct */ -}}
{{define "generateDefinePopulateMapsStructs"}}
  {{ template "generateDefinePopulateMapsStruct" . }}
  {{ template "nestedDefinePopulateMapsStructsRecursive" . }}
{{- end}}

{{- /* Define populate maps struct */ -}}
{{define "nestedDefinePopulateMapsStructsRecursive"}}
  {{- range .NestedStructs -}}
    {{- if and (not .SkipStructGeneration) (not .IsRoot) (.IsComposite) }} 
      {{ template "generateDefinePopulateMapsStruct" . }}
      {{ template "nestedDefinePopulateMapsStructsRecursive" . }}
    {{- end}}
  {{- end -}}
{{- end}}

{{- /* Define nested row getter interfaces */ -}}
{{define "generateRowGetterInterfaceMethodsRecursive"}}
  {{- $parentStruct := index . 0 -}}
  {{- $query := index . 1 -}}
  {{- $options := index . 2 -}}
  {{- $renderedMethods := index . 3 -}}

  {{- $modelsPackage := $options.OutputModelsPackage -}}
  {{- range $parentStruct.NestedStructs -}}
    {{- $methodSignature := printf "Get%s() %s" .RowFieldName .RowFieldType -}}
    {{- if and (hasPrefix .RowFieldType $modelsPackage) (.IsRowFieldExistsInQuery) -}}
      {{- /* Check if we already rendered this method */ -}}
      {{- if not (index $renderedMethods $methodSignature) }}
        {{$methodSignature}}
        {{- /* Mark this method as rendered */ -}}
        {{- $_ := set $renderedMethods $methodSignature true -}}
      {{- end}}
    {{- end}}
    {{- if or .IsComposite (gt (len .NestedStructs) 0) }}
      {{- template "generateRowGetterInterfaceMethodsRecursive" (list . $query $options $renderedMethods) }}
    {{- end}}
  {{- end -}}
{{- end}}

{{- /* Define row getter interfaces */ -}}
{{define "generateRowGetterInterface"}}
  {{- $currentStruct := index . 0 -}}
  {{- $tempateData := index . 1 -}}
  {{- $options := index . 2 -}}

  {{- $query := $tempateData.Query -}}
  {{- $modelsPackage := $options.OutputModelsPackage -}}
  {{- $RowStructName := printf "%sRow" $tempateData.Query.MethodName -}}
  {{- $RowGetterInterfaceName := printf "%sRowGetter" $currentStruct.StructOut -}}

  // {{$RowGetterInterfaceName}} represents row getter interface for {{$RowStructName}}
  type {{$RowGetterInterfaceName}} interface {
    {{- /* Initialize map to track rendered methods and prevent duplicates */ -}}
    {{template "generateRowGetterInterfaceMethodsRecursive" (list $currentStruct $query $options dict) }}
  }
{{- end}}

{{- /* Define nested row getter interfaces */ -}}
{{define "nestedGenerateRowGetterInterfacesRecursive"}}
  {{- $parentStruct := index . 0 -}}
  {{- $tempateData := index . 1 -}}
  {{- $options := index . 2 -}}

  {{- range $parentStruct.NestedStructs -}}
    {{- if and (not .SkipStructGeneration) (not .IsRoot) (.IsComposite) }} 
      {{ template "generateRowGetterInterface" (list . $tempateData $options) }}
      {{ template "nestedGenerateRowGetterInterfacesRecursive" (list . $tempateData $options) }}
    {{- end}}
  {{- end -}}
{{- end}}

{{- /* Define row getter interfaces */ -}}
{{define "generateRowGetterInterfaces"}}
  {{- $currentStruct := index . 0 -}}
  {{- $tempateData := index . 1 -}}
  {{- $options := index . 2 -}}

  {{ template "generateRowGetterInterface" (list $currentStruct $tempateData $options) }}
  {{ template "nestedGenerateRowGetterInterfacesRecursive" (list $currentStruct $tempateData $options) }}
{{ end }}

{{define "generateInitPopulateMapsStructFieldsRecursive"}}
  {{- $parentStruct := index . 0 -}}
  {{- $leftLevel := index . 1 -}}
  {{- $rightLevel := index . 2 -}}
  {{- $prefixLeft := index . 3 -}}
  {{- $prefixRight := index . 4 -}}
  {{- $mapSourceName := index . 5 -}}

  {{- range $parentStruct.NestedStructs }}
    {{- $StructName := printf "%s" (ternary .IsEntityStruct (printf "entity.%s" .StructIn) .StructOut) }}
    {{- $structMapItem := .StructOut | camelCase }}
    {{- $structMaps := printf "%sMaps" $structMapItem }}
    {{- $nextPrefixLeft := render "nextMapPrefix" (list . $parentStruct $leftLevel $prefixLeft) -}}
    {{- $nextPrefixRight := render "nextMapPrefix" (list . $parentStruct $rightLevel $prefixRight) -}}

    {{- /* Left part of the assignment */ -}}
    {{- $structMapsAssignmentLeft := render "prefixedMapName" (list . $nextPrefixLeft) -}}

    {{- /* Right part of the assignment */ -}}
    {{- $prefixedStructMaps := render "prefixedMapName" (list . $nextPrefixRight) -}}
    {{- $structMapsAssignmentRight := printf "%s" (ternary (eq $mapSourceName "") $prefixedStructMaps (printf "%s.%s" $mapSourceName $prefixedStructMaps)) -}}

    {{- /* Rendered fields */ -}}
    {{- $structMapsAssignmentLeft}}: {{$structMapsAssignmentRight}},
    {{template "generateInitPopulateMapsStructFieldsRecursive" (list . (add $leftLevel 1) (add $rightLevel 1) $nextPrefixLeft $nextPrefixRight $mapSourceName) }} 
  {{- end -}}
{{- end }}

{{- /* Init populate maps struct */ -}}
{{define "generateInitPopulateMapsStruct"}}
  {{- $currentStruct := index . 0 -}}
  {{- $leftLevel := index . 1 -}}
  {{- $rightLevel := index . 2 -}}
  {{- $mapSourceName := index . 3 -}}
  {{- $prefixLeft := index . 4 -}}
  {{- $prefixRight := index . 5 -}}
  
  {{- $PopulateRootStructName := printf "Populate%sMaps" $currentStruct.StructOut -}}

  {{- /* Rendered struct definition */ -}}
  {{$PopulateRootStructName}}{
    {{ template "generateInitPopulateMapsStructFieldsRecursive" (list $currentStruct $leftLevel $rightLevel $prefixLeft $prefixRight $mapSourceName) }}
  }
{{- end}}

{{- /* Recursive grouper function content */ -}}
{{define "nestedGrouperRecursiveContent"}}
  {{- $parentStruct := index . 0 -}}
  {{- $level := index . 1 -}}
  {{- $prefix := index . 2 -}}
  {{- $parentStructMapItem := $parentStruct.StructOut | camelCase }}
  {{- $parentStructMap := printf "%sMap" $parentStructMapItem }}
  {{- $parentStructMapsID := printf "%sMapsID" $parentStructMapItem }}

  {{ range $parentStruct.NestedStructs}}
    {{- $currentStruct := .}}
    {{- $currentStructMapItem := $currentStruct.StructOut | camelCase }}
    {{- $currentStructMap := printf "%sMap" $currentStructMapItem }}
    {{- $currentStructMaps := printf "%sMaps" $currentStructMapItem }}
    {{- $currentStructMapsID := printf "%sMapsID" $currentStructMapItem }}
    {{- $structFieldGetter := printf "Get%s()" $currentStruct.StructIn }}
    {{- $structFieldResult := $currentStruct.StructIn | camelCase }}
    {{- $PopulateStructName := printf "Populate%sMaps" .StructOut }}
    {{- $nextPrefix := render "nextMapPrefix" (list . $parentStruct $level $prefix) -}}
    {{- $prefixedCurrentStructMaps := render "prefixedMapName" (list . $nextPrefix) -}}

    // Handle {{.StructOut}} nested relationship
    if r.{{$structFieldGetter}}.ID.Valid {
      {{$currentStructMapsID}} := {{$parentStructMapItem}}.{{$parentStruct.FieldGroupBy}}.String()
      {{$currentStructMap}} := getOrCreateNestedMap(maps.{{$prefixedCurrentStructMaps}}, {{$currentStructMapsID}})
      {{$structFieldResult}} := r.{{$structFieldGetter}}

      {{ if $currentStruct.IsComposite }}
        // For composite structs we populate the entity afterwards
        {{$currentStructMapItem}} := getOrCreate{{.StructOut}}From{{$currentStruct.StructIn}}({{$currentStructMap}}, &{{$structFieldResult}})
        {{ if .IsSlice}}
          // Update parent
          {{$parentStructMapItem}}.{{.FieldName}} = append({{$parentStructMapItem}}.{{.FieldName}}, {{$currentStructMapItem}})
        {{ else}}
          // Update parent
          if {{$parentStructMapItem}}.{{.FieldName}} == nil || {{$parentStructMapItem}}.{{.FieldName}}.{{$currentStruct.FieldGroupBy}} != {{$currentStructMapItem}}.{{$currentStruct.FieldGroupBy}} {
            {{$parentStructMapItem}}.{{.FieldName}} = {{$currentStructMapItem}}
          }          
        {{- end}}
        
        shouldPopulate := false
        {{- range .Match}}
          if r.Get{{.FromStruct}}().{{.FromField}} == r.Get{{.ToStruct}}().{{.ToField}} {
            shouldPopulate = true
          }
        {{- end}}

        if (shouldPopulate) {
          populate{{$currentStruct.StructOut}}(
          {{$currentStructMapItem}}, 
          &{{- template "generateInitPopulateMapsStruct" (list . 1 (add $level 1) "maps" "" $nextPrefix) -}}, 
            row,
          )
        }
      {{- else }}
        {{if gt (len $currentStruct.NestedStructs) 0 }}{{$currentStructMapItem}} := {{end}}set{{.StructOut}}For{{$parentStruct.StructOut}}({{$parentStructMapItem}}, {{$currentStructMap}}, &{{$structFieldResult}})
        {{- if gt (len $currentStruct.NestedStructs) 0 }}{{- template "nestedGrouperRecursiveContent" (list . (add $level 1) $nextPrefix) }}{{- end}}
      {{- end }}
    }
  {{- end}}
{{end}}

{{- /* Generate function to populate composite from entity */ -}}
{{define "generatePopulateCompositeFromEntityFunction"}}
  {{- $currentStruct := index . 0 -}}
  {{- $options := index . 1 -}}
  {{- $modelsPackage := $options.OutputModelsPackage -}}

  {{ with $currentStruct}}
    {{- $currentStructMapItem := .StructOut | camelCase }}
    {{- $currentStructMap := printf "%sMap" $currentStructMapItem }}
    {{- $currentStructInItem := .StructIn | camelCase }}

    {{- $functionName := printf "getOrCreate%sFrom%s" .StructOut .StructIn }}

    // {{$functionName}} gets or creates a {{.StructOut}} from the {{.StructIn}} structure
    func {{$functionName}}({{$currentStructMap}} map[{{.KeyType}}]*{{.StructOut}}, {{$currentStructInItem}} *{{$modelsPackage}}.{{.StructIn}}) *{{.StructOut}} {
      // Check if item already exists in correspoding map for {{.StructOut}}
      if item, exists := {{$currentStructMap}}[{{$currentStructInItem}}.{{.FieldGroupBy}}]; exists {
        return item
      }

      // Create {{.StructOut}} instance
      {{$currentStructMapItem}} := &{{.StructOut}}{
        {{- range .Fields}}
          {{.Name}}: {{$currentStructInItem}}.{{.Name}},
        {{- end}}
      }
      {{$currentStructMap}}[{{$currentStructInItem}}.{{.FieldGroupBy}}] = {{$currentStructMapItem}}

      return {{$currentStructMapItem}}
    }
  {{end}}
{{end}}

{{- /* Generate functions to populate composite from entity recursively */ -}}
{{define "nestedPopulateCompositeFromEntityFunctionsRecursive"}}
  {{- $parentStruct := index . 0 -}}
  {{- $options := index . 1 -}}
  {{- $modelsPackage := $options.OutputModelsPackage -}}

  {{- if $parentStruct.IsRoot }}
    {{- template "generatePopulateCompositeFromEntityFunction" (list $parentStruct $options) }}
  {{- end}}
  
  {{- range $parentStruct.NestedStructs}}
    {{- if and (not .SkipStructGeneration) (not .IsRoot) (.IsComposite) }}
      {{- template "generatePopulateCompositeFromEntityFunction" (list . $options) }}
      {{- template "nestedPopulateCompositeFromEntityFunctionsRecursive" (list . $options) }}
    {{- end}}
  {{- end}}
{{end}}

{{- /* Recursive populate functions */ -}}
{{define "nestedPopulateFunctionsRecursive"}}
  {{- $parentStruct := .}}

  {{- range $parentStruct.NestedStructs}}
    {{- if and (not .SkipStructGeneration) (not .IsRoot) (.IsComposite) }} 
      {{- $structMapItem := .StructOut | camelCase }}
      {{- $PopulateRootStructName := printf "Populate%sMaps" .StructOut }}

      // populate{{.StructOut}} populates a {{.StructOut}} from the row
      func populate{{.StructOut}}[R {{.StructOut}}RowGetter](
        {{$structMapItem}} *{{.StructOut}},
        maps *{{$PopulateRootStructName}}, 
        row *R,
      ) *{{.StructOut}} {
        // Get row
        r := *row

        {{ template "nestedGrouperRecursiveContent" (list . 1 "") }}

        return {{$structMapItem}}
      }
    {{- end}}

    {{ template "nestedPopulateFunctionsRecursive" .}}
  {{- end}}
{{end}}

{{- /* Recursive mappers functions */ -}}
{{define "nestedMappersFunctionsRecursive"}}
  {{- $parentStruct := .}}
  {{- $ParentStructName := printf "%s" (ternary $parentStruct.IsEntityStruct (printf "entity.%s" $parentStruct.StructIn) $parentStruct.StructOut) }}

  {{- range .NestedStructs}}
    {{- $currentStruct := .}}
    {{- if and (not .SkipStructGeneration)}}
      {{- if .IsEntityStruct }}
        {{- $functionName := printf "set%sFor%s" .StructOut $parentStruct.StructOut }}
        {{- $currentStructType := ternary .IsEntityStruct (printf "entity.%s" .StructIn) .StructOut }}
        {{- $currentStructMapItem := $currentStruct.StructOut | camelCase }}
        {{- $currentStructMap := printf "%sMap" $currentStructMapItem }}
        {{- $currentStructInItem := $currentStruct.StructIn | camelCase }}

        {{- $CurrentStructName := printf "%s" (ternary .IsEntityStruct (printf "entity.%s" .StructIn) .StructOut) }}

        // {{$functionName}} gets or creates a {{.StructOut}} within the {{.StructOut}} structure
        func {{$functionName}}(parent *{{$ParentStructName}}, {{$currentStructMap}} map[{{$currentStruct.KeyType}}]*{{$CurrentStructName}}, {{$currentStructInItem}} *entity.{{.StructIn}}) *{{$CurrentStructName}} {
          // Check if entity already exists in map correspoding to parent slice
          if entity, exists := {{$currentStructMap}}[{{$currentStructInItem}}.{{$currentStruct.FieldGroupBy}}]; exists {
            return entity
          }

          {{if .IsEntityStruct}}
            // For entity structs, we use the entity directly
            entity := {{$currentStructInItem}}
          {{- else if .IsComposite}}
            // For composite structs, we create composite struct
            entity := &{{$currentStructType}}{
              {{- range .Fields}}
              {{.Name}}: {{$currentStructInItem}}.{{.Name}},
              {{- end}}
            }
          {{- end}}
        
          {{ if .IsSlice}}
            // Add to slice
            parent.{{.FieldName}} = append(parent.{{.FieldName}}, entity)
          {{ else}}
            // Sent parent entity if not already set
            if parent.{{.FieldName}} != nil && parent.{{.FieldName}}.{{$currentStruct.FieldGroupBy}} == entity.{{$currentStruct.FieldGroupBy}} {
              return parent.{{.FieldName}}
            }
            parent.{{.FieldName}} = entity
          {{- end}}

          // Add to map to check next time if entity already set
          {{$currentStructMap}}[entity.{{$currentStruct.FieldGroupBy}}] = entity

          return entity
        }
      {{- end }}
      {{ template "nestedMappersFunctionsRecursive" . }}
    {{- end}}
  {{- end}}
{{end}}

{{- /* Root nested core template */ -}}
{{ define "nestedCore" -}}
  {{- $options := . -}}

  {{- range .Nested }}
    {{- /* Filter structs for particular query */ -}}
    {{- if eq .SourceFileName $.SourceName }}
      {{- range .NestedDataItems }}
        {{- $templateData := . }}
        {{- $QueryName := .Query.MethodName }}
        {{- $ptr := ternary .EmitPointers "*" ""}}
        {{- $RowStructName := printf "%s%sRow" $ptr $QueryName }}
        
        {{- /* Generate structs */ -}}
        {{- if .RootStructData }}
          {{- if not .RootStructData.SkipStructGeneration }}
            {{- with .RootStructData }}
              {{- /* Generate root struct */ -}}
              {{ template "generateStruct" (list . $templateData) }}

              {{- /* Generate nested structs recursively */ -}}
              {{ template "generateNestedStructs" (list .NestedStructs $templateData) }}

              {{- /* Generate populate maps struct */ -}}
              {{ template "generateDefinePopulateMapsStructs" . }}

              {{/* Generate row getter interface */}}
              {{ template "generateRowGetterInterfaces" (list . $templateData $options) }}
            {{- end }}
          {{- end }}
        {{- end }}
      {{- end }}

      {{- /* Generate functions */ -}}
      {{- range .NestedDataItems }}
        {{- $templateData := . }}

        {{- $ptr := ternary .EmitPointers "*" ""}}
        {{- $oppositePtr := ternary .EmitPointers "" "*"}}
        {{- $QueryName := .Query.MethodName }}
        {{- $RowStructName := printf "%s%sRow" $ptr $QueryName }}
        {{- $RootStructName := .RootStructName }}
        {{- $PopulateRootStructName := printf "Populate%sMaps" $RootStructName }}
        {{- $RootStructNameGeneric := printf "%sRowGetter" $RootStructName }}
        {{- $rootStructMapItem := .RootStructName | camelCase }}
        {{- $rootStructMap := printf "%sMap" $rootStructMapItem }}
        {{- $RootFunctionName := .FunctionName }}
        
        {{- if .RootStructData }}
          {{- if not .RootStructData.SkipStructGeneration }}
            {{- with .RootStructData }}
              // {{$RootFunctionName}} groups flat {{$QueryName}} rows into nested {{$RootStructName}} structures
              func {{$RootFunctionName}}(rows []{{$RowStructName}}) []{{$ptr}}{{$RootStructName}} {
                {{- /* Declare map for the root struct */}}
                // Result map
                {{$rootStructMap}} := make(map[{{.KeyType}}]*{{$RootStructName}})
                
                {{/* Declare nested maps for the root struct recursively */}}
                // Maps for faster grouping
                {{- template "nestedMapsRecursive" (list . 1 "") }}

                {{/* Declare nested structs mapper */}}
                for _, row := range rows {
                  {{$rootStructMapItem}} := getOrCreate{{$RootStructName}}({{$rootStructMap}}, row)
                populate{{$RootStructName}}(
                  {{$rootStructMapItem}},
                  &{{- template "generateInitPopulateMapsStruct" (list . 1 1 "" "" "") -}},
                  row,
                )
                }
                
                var result []{{$ptr}}{{$RootStructName}}
                for _, {{$rootStructMapItem}} := range {{$rootStructMap}} {
                  result = append(result, {{$oppositePtr}}{{$rootStructMapItem}})
                }

                return result
              }

              // populate{{$RootStructName}} populates a {{$RootStructName}} from the row
              func populate{{$RootStructName}}[R {{$RootStructNameGeneric}}](
                {{$rootStructMapItem}} *{{$RootStructName}},
                maps *{{$PopulateRootStructName}}, 
                row *R,
              ) *{{$RootStructName}} {
                // Get row
                r := *row

                {{ template "nestedGrouperRecursiveContent" (list . 1 "")}}

                return {{$rootStructMapItem}}
              }

              {{ template "nestedPopulateFunctionsRecursive" . }}

              // getOrCreate{{$RootStructName}} gets or creates a {{$RootStructName}} from the map
              func getOrCreate{{$RootStructName}}({{$rootStructMap}} map[{{.KeyType}}]*{{$RootStructName}}, row {{$RowStructName}}) *{{$RootStructName}} {
                // Check if entity already exists in map
                if {{$rootStructMapItem}}, exists := {{$rootStructMap}}[row.{{.FieldGroupBy}}]; exists {
                  return {{$rootStructMapItem}}
                }

                // Create entity
                {{$rootStructMapItem}} := &{{$RootStructName}}{
                  {{- range .Fields}}
                    {{.Name}}: row.{{.Name}},
                  {{- end}}
                }
                {{$rootStructMap}}[row.{{.FieldGroupBy}}] = {{$rootStructMapItem}}

                return {{$rootStructMapItem}}
              }

              {{ template "nestedMappersFunctionsRecursive" . }}

              {{ template "nestedPopulateCompositeFromEntityFunctionsRecursive" (list . $options) }}
            {{ end }}
          {{- end }}
        {{- else }}
          {{- /* Generate wrapper function */ -}}
          {{ template "nestedGeneratedQueryGroupWrapper" $templateData }}
        {{- end }}
      {{- end }}

    {{- end }}
  {{- end }}
{{- end }}